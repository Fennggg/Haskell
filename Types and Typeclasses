ghci>:t 'a'  
'a' :: Char
ghci>:t True  
True :: Bool
ghci>
ghci>:t 'a'  
'a' :: Char
ghci>:t True  
True :: Bool
ghci>:t "HELLO!"
"HELLO!" :: [Char]
ghci>:t (True, 'a')  
(True, 'a') :: (Bool, Char)
ghci>:t 4 == 5  
4 == 5 :: Bool
ghci>factorial n = product [1..n]  
ghci>factorial 50 
30414093201713378043612608166064768844377641568960512000000000000
ghci>circumference r = 2 * pi * r  
ghci>circumference 4.0  
25.132741228718345
ghci>circumference' r = 2 * pi * r 
ghci> circumference' 4.0 
25.132741228718345
ghci>:t head  
head :: [a] -> a
ghci>:t fst 
fst :: (a, b) -> a
ghci>:t (==)
(==) :: Eq a => a -> a -> Bool
ghci>5 == 5
True
ghci>5 /= 5  
False
ghci>'a' == 'a'  
True
ghci> "Ho Ho" == "Ho Ho"  
True
ghci>3.432 == 3.432  
True
ghci>:t (>)  
(>) :: Ord a => a -> a -> Bool
ghci>"Abrakadabra" < "Zebra"  
True
ghci> "Abrakadabra" `compare` "Zebra" 
LT
ghci> 5 >= 2 
True
ghci>5 `compare` 3  
GT
ghci> show 3  
"3"
ghci>show 5.334 
"5.334"
ghci>show True 
"True"
ghci>read "True" || False  
True
ghci>read "8.2" + 3.8  
12.0
ghci>read "5" - 2
3
ghci>read "[1,2,3,4]" ++ [3]  
[1,2,3,4,3]
ghci> read "4"  
*** Exception: Prelude.read: no parse
ghci>:t read
read :: Read a => String -> a
ghci> read "5" :: Int  
5
ghci>read "5" :: Float  
5.0
ghci>(read "5" :: Float) * 4  
20.0
ghci>read "[1,2,3,4]" :: [Int] 
[1,2,3,4]
ghci>read "(3, 'a')" :: (Int, Char)
(3,'a')
ghci>['a'..'e']
"abcde"
ghci>[LT .. GT] 
[LT,EQ,GT]
ghci>[3 .. 5] 
[3,4,5]
ghci> succ 'B'  
'C'
ghci>minBound :: Int  
-9223372036854775808
ghci>maxBound :: Char 
'\1114111'
ghci>maxBound :: Bool  
True
ghci>minBound :: Bool  
False
ghci>maxBound :: (Bool, Int, Char)  
(True,9223372036854775807,'\1114111')
ghci> :t 20  
20 :: Num p => p
ghci> 20 :: Int
20
ghci>20 :: Integer 
20
ghci>20 :: Float  
20.0
ghci>20 :: Double 
20.0
ghci>:t (*)
(*) :: Num a => a -> a -> a
ghci>

