ghci>data Shape = Circle Float Float Float | Rectangle Float Float Float Float   
ghci>:t Circle  
Circle :: Float -> Float -> Float -> Shape
ghci>:t Rectangle  
Rectangle :: Float -> Float -> Float -> Float -> Shape
ghci>surface (Circle _ _ r) = pi * r ^ 2  
ghci>surface (Rectangle x1 y1 x2 y2) = (abs $ x2 - x1) * (abs $ y2 - y1)  
ghci>surface $ Circle 10 20 10  
*** Exception: <interactive>:322:1-67: Non-exhaustive patterns in function surface

ghci>surface $ Rectangle 0 0 100 100  
10000.0
ghci>data Shape = Circle Float Float Float | Rectangle Float Float Float Float deriving (Show)  
ghci>Circle 10 20 5  
Circle 10.0 20.0 5.0
ghci>Rectangle 50 230 60 90 
Rectangle 50.0 230.0 60.0 90.0
ghci>map (Circle 10 20) [4,5,6,6]  
[Circle 10.0 20.0 4.0,Circle 10.0 20.0 5.0,Circle 10.0 20.0 6.0,Circle 10.0 20.0 6.0]
ghci>surface (Circle _ r) = pi * r ^ 2  

<interactive>:329:10: error:
    • The constructor ‘Circle’ should have 3 arguments, but has been given 2
    • In the pattern: Circle _ r
      In an equation for ‘surface’: surface (Circle _ r) = pi * r ^ 2
ghci>data Point = Point Float Float deriving (Show)  
ghci>data Shape = Circle Point Float | Rectangle Point Point deriving (Show)
ghci>surface (Circle _ r) = pi * r ^ 2  
ghci>surface (Rectangle (Point x1 y1) (Point x2 y2)) = (abs $ x2 - x1) * (abs $ y2 - y1)  
ghci> surface (Rectangle (Point 0 0) (Point 100 100))  
10000.0
ghci>surface (Circle (Point 0 0) 24) 
*** Exception: <interactive>:333:1-83: Non-exhaustive patterns in function surface

ghci>(Circle (Point x y) r) a b = Circle (Point (x+a) (y+b)) r  

<interactive>:336:1: error:
    Parse error in pattern: (Circle (Point x y) r)
ghci>nudge (Circle (Point x y) r) a b = Circle (Point (x+a) (y+b)) r  
ghci>nudge (Circle (Point 34 34) 10) 5 10 
Circle (Point 39.0 44.0) 10.0
ghci>baseCircle r = Circle (Point 0 0) r  
ghci>baseRect width height = Rectangle (Point 0 0) (Point width height)  
ghci>nudge (baseRect 40 100) 60 23  
*** Exception: <interactive>:337:1-63: Non-exhaustive patterns in function nudge

ghci>data Person = Person String String Int Float String String deriving (Show)  
ghci> let guy = Person "Buddy" "Finklestein" 43 184.2 "526-2928" "Chocolate" 
ghci>guy  
Person "Buddy" "Finklestein" 43 184.2 "526-2928" "Chocolate"
ghci>firstName (Person firstname _ _ _ _ _) = firstname  
ghci> let guy = Person "Buddy" "Finklestein" 43 184.2 "526-2928" "Chocolate"
ghci>firstName guy  
"Buddy"
ghci>height (Person _ _ _ height _ _) = height 
ghci>height guy  
184.2
ghci>flavor (Person _ _ _ _ _ flavor) = flavor  
ghci>flavor guy  
"Chocolate"
ghci>data Car = Car String String Int deriving (Show)  
ghci>Car "Ford" "Mustang" 1967  
Car "Ford" "Mustang" 1967
ghci>data Car = Car {company :: String, model :: String, year :: Int} deriving (Show) 
ghci>Car {company="Ford", model="Mustang", year=1967}  
Car {company = "Ford", model = "Mustang", year = 1967}
ghci>data Maybe a = Nothing | Just a  
ghci>Just "Haha"

<interactive>:357:1: error:
    • No instance for (Show (Maybe [Char]))
        arising from a use of ‘print’
      There are instances for similar types:
        instance Show a => Show (Prelude.Maybe a) -- Defined in ‘GHC.Show’
    • In a stmt of an interactive GHCi command: print it
ghci>Just 84  

<interactive>:358:1: error:
    • No instance for (Show (Maybe Integer))
        arising from a use of ‘print’
      There are instances for similar types:
        instance Show a => Show (Prelude.Maybe a) -- Defined in ‘GHC.Show’
    • In a stmt of an interactive GHCi command: print it
ghci>tellCar (Car {company = c, model = m, year = y}) = "This " ++ c ++ " " ++ m ++ " was made in " ++ show y  
ghci>let stang = Car {company="Ford", model="Mustang", year=1967}  
ghci>tellCar stang  
"This Ford Mustang was made in 1967"
ghci>tellCar (Car {company = c, model = m, year = y}) = "This " ++ c ++ " " ++ m ++ " was made in " ++ show y  
ghci>tellCar (Car "Ford" "Mustang" 1967)  
"This Ford Mustang was made in 1967"
ghci>tellCar (Car "Ford" "Mustang" "nineteen sixty seven") 

<interactive>:364:31: error:
    • Couldn't match expected type ‘Int’ with actual type ‘[Char]’
    • In the third argument of ‘Car’, namely ‘"nineteen sixty seven"’
      In the first argument of ‘tellCar’, namely
        ‘(Car "Ford" "Mustang" "nineteen sixty seven")’
      In the expression:
        tellCar (Car "Ford" "Mustang" "nineteen sixty seven")
ghci>:t Car "Ford" "Mustang" 1967  
Car "Ford" "Mustang" 1967 :: Car
ghci>:t Car "Ford" "Mustang" "nineteen sixty seven"  
ghci>data Vector a = Vector a a a deriving (Show)  
ghci>(Vector i j k) `vplus` (Vector l m n) = Vector (i+l) (j+m) (k+n)  
ghci>(Vector i j k) `vectMult` m = Vector (i*m) (j*m) (k*m)  
ghci>(Vector i j k) `scalarMult` (Vector l m n) = i*l + j*m + k*n  
ghci>Vector 3 5 8 `vplus` Vector 9 2 8  
Vector 12 7 16
ghci>Vector 3 5 8 `vplus` Vector 9 2 8 `vplus` Vector 0 2 3  
Vector 12 9 19
ghci>Vector 3 9 7 `vectMult` 10  
Vector 30 90 70
ghci>Vector 4 9 5 `scalarMult` Vector 9.0 2.0 4.0  
74.0
ghci>Vector 2 9 3 `vectMult` (Vector 4 9 5 `scalarMult` Vector 9 2 4)
Vector 148 666 222

ghci>data Bool = False | True  
ghci>data Int = -2147483648 | -2147483647 | ... | -1 | 0 | 1 | 2 | ... | 2147483647

<interactive>:317:12: error: parse error on input ‘-’
ghci>data Shape = Circle Float Float Float | Rectangle Float Float Float Float   
ghci>:t Circle  
Circle :: Float -> Float -> Float -> Shape
ghci>:t Rectangle  
Rectangle :: Float -> Float -> Float -> Float -> Shape
ghci>surface (Circle _ _ r) = pi * r ^ 2  
ghci>surface (Rectangle x1 y1 x2 y2) = (abs $ x2 - x1) * (abs $ y2 - y1)  
ghci>surface $ Circle 10 20 10  
*** Exception: <interactive>:322:1-67: Non-exhaustive patterns in function surface

ghci>surface $ Rectangle 0 0 100 100  
10000.0
ghci>data Shape = Circle Float Float Float | Rectangle Float Float Float Float deriving (Show)  
ghci>Circle 10 20 5  
Circle 10.0 20.0 5.0
ghci>Rectangle 50 230 60 90 
Rectangle 50.0 230.0 60.0 90.0
ghci>map (Circle 10 20) [4,5,6,6]  
[Circle 10.0 20.0 4.0,Circle 10.0 20.0 5.0,Circle 10.0 20.0 6.0,Circle 10.0 20.0 6.0]
ghci>surface (Circle _ r) = pi * r ^ 2  
ghci>data Point = Point Float Float deriving (Show)  
ghci>data Shape = Circle Point Float | Rectangle Point Point deriving (Show)
ghci>surface (Circle _ r) = pi * r ^ 2  
ghci>surface (Rectangle (Point x1 y1) (Point x2 y2)) = (abs $ x2 - x1) * (abs $ y2 - y1)  
ghci> surface (Rectangle (Point 0 0) (Point 100 100))  
10000.0
ghci>surface (Circle (Point 0 0) 24) 
*** Exception: <interactive>:333:1-83: Non-exhaustive patterns in function surface

ghci>(Circle (Point x y) r) a b = Circle (Point (x+a) (y+b)) r  

<interactive>:336:1: error:
    Parse error in pattern: (Circle (Point x y) r)
ghci>nudge (Circle (Point x y) r) a b = Circle (Point (x+a) (y+b)) r  
ghci>nudge (Circle (Point 34 34) 10) 5 10 
Circle (Point 39.0 44.0) 10.0
ghci>baseCircle r = Circle (Point 0 0) r  
ghci>baseRect width height = Rectangle (Point 0 0) (Point width height)  
ghci>nudge (baseRect 40 100) 60 23  
*** Exception: <interactive>:337:1-63: Non-exhaustive patterns in function nudge

ghci>data Person = Person String String Int Float String String deriving (Show)  
ghci> let guy = Person "Buddy" "Finklestein" 43 184.2 "526-2928" "Chocolate" 
ghci>guy  
Person "Buddy" "Finklestein" 43 184.2 "526-2928" "Chocolate"
ghci>firstName (Person firstname _ _ _ _ _) = firstname  
ghci> let guy = Person "Buddy" "Finklestein" 43 184.2 "526-2928" "Chocolate"
ghci>firstName guy  
"Buddy"
ghci>height (Person _ _ _ height _ _) = height 
ghci>height guy  
184.2
ghci>flavor (Person _ _ _ _ _ flavor) = flavor  
ghci>flavor guy  
"Chocolate"
ghci>data Car = Car String String Int deriving (Show)  
ghci>Car "Ford" "Mustang" 1967  
Car "Ford" "Mustang" 1967
ghci>data Car = Car {company :: String, model :: String, year :: Int} deriving (Show) 
ghci>Car {company="Ford", model="Mustang", year=1967}  
Car {company = "Ford", model = "Mustang", year = 1967}
ghci>data Maybe a = Nothing | Just a  
ghci>Just "Haha"
ghci>tellCar (Car {company = c, model = m, year = y}) = "This " ++ c ++ " " ++ m ++ " was made in " ++ show y  
ghci>let stang = Car {company="Ford", model="Mustang", year=1967}  
ghci>tellCar stang  
"This Ford Mustang was made in 1967"
ghci>tellCar (Car {company = c, model = m, year = y}) = "This " ++ c ++ " " ++ m ++ " was made in " ++ show y  
ghci>tellCar (Car "Ford" "Mustang" 1967)  
"This Ford Mustang was made in 1967"
ghci>tellCar (Car "Ford" "Mustang" "nineteen sixty seven") 

<interactive>:364:31: error:
    • Couldn't match expected type ‘Int’ with actual type ‘[Char]’
    • In the third argument of ‘Car’, namely ‘"nineteen sixty seven"’
      In the first argument of ‘tellCar’, namely
        ‘(Car "Ford" "Mustang" "nineteen sixty seven")’
      In the expression:
        tellCar (Car "Ford" "Mustang" "nineteen sixty seven")
ghci>:t Car "Ford" "Mustang" 1967  
Car "Ford" "Mustang" 1967 :: Car
ghci>:t Car "Ford" "Mustang" "nineteen sixty seven"  

<interactive>:1:22: error:
    • Couldn't match expected type ‘Int’ with actual type ‘[Char]’
    • In the third argument of ‘Car’, namely ‘"nineteen sixty seven"’
      In the expression: Car "Ford" "Mustang" "nineteen sixty seven"
ghci>data Vector a = Vector a a a deriving (Show)  
ghci>(Vector i j k) `vplus` (Vector l m n) = Vector (i+l) (j+m) (k+n)  
ghci>(Vector i j k) `vectMult` m = Vector (i*m) (j*m) (k*m)  
ghci>(Vector i j k) `scalarMult` (Vector l m n) = i*l + j*m + k*n  
ghci>Vector 3 5 8 `vplus` Vector 9 2 8  
Vector 12 7 16
ghci>Vector 3 5 8 `vplus` Vector 9 2 8 `vplus` Vector 0 2 3  
Vector 12 9 19
ghci>Vector 3 9 7 `vectMult` 10  
Vector 30 90 70
ghci>Vector 4 9 5 `scalarMult` Vector 9.0 2.0 4.0  
74.0
ghci>Vector 2 9 3 `vectMult` (Vector 4 9 5 `scalarMult` Vector 9 2 4)
Vector 148 666 222
ghci>let mikeD = Person {firstName = "Michael", lastName = "Diamond", age = 43}  

ghci>type String = [Char]  
ghci>phoneBook :: [(String,String)]  

<interactive>:395:1: error:
    Variable not in scope: phoneBook :: [(String, String)]
ghci>type PhoneBook = [(String,String)]  
ghci>type PhoneNumber = String 
ghci>type Name = String  
ghci>type PhoneBook = [(Name,PhoneNumber)]  
ghci>type AssocList k v = [(k,v)]  
ghci>type IntMap v = Map Int v  
ghci>data Either a b = Left a | Right b deriving (Eq, Ord, Read, Show)  
ghci>Right 20  
Right 20
ghci>Left "w00t"
Left "w00t"
ghci>:t Right 'a'  
Right 'a' :: Either a Char
ghci>:t Left True  
Left True :: Either Bool b
ghci>import qualified Data.Map as Map  
ghci>data LockerState = Taken | Free deriving (Show, Eq)  
ghci>type Code = String  
ghci>type LockerMap = Map.Map Int (LockerState, Code)  
ghci>lockerLookup 101 lockers  
ghci>data List a = Empty | Cons a (List a) deriving (Show, Read, Eq, Ord)  
ghci>data List a = Empty | Cons { listHead :: a, listTail :: List a} deriving (Show, Read, Eq, Ord)  
ghci>Empty 
Empty
ghci>5 `Cons` Empty  
Cons {listHead = 5, listTail = Empty}
ghci>4 `Cons` (5 `Cons` Empty) 
Cons {listHead = 4, listTail = Cons {listHead = 5, listTail = Empty}}
ghci>3 `Cons` (4 `Cons` (5 `Cons` Empty))  
Cons {listHead = 3, listTail = Cons {listHead = 4, listTail = Cons {listHead = 5, listTail = Empty}}}
ghci>infixr 5 :-: 
ghci> a .++ b  
ghci>data Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show, Read, Eq)
ghci>singleton x = Node x EmptyTree EmptyTree 
ghci>treeInsert :: (Ord a) => a -> Tree a -> Tree a  
ghci>instance YesNo Int where 
ghci> yesno 0 = False  
ghci>yesno _ = True  
ghci>instance YesNo [a] where  
ghci>yesno [] = False  
ghci>    yesno _ = True 
ghci>instance YesNo Bool where  
ghci>    yesno = id    
ghci>instance YesNo (Maybe a) where  
ghci>    yesno (Just _) = True  
ghci>    yesno Nothing = False  
ghci>instance YesNo (Tree a) where  
ghci>    yesno EmptyTree = False  
ghci>    yesno _ = True  
ghci>instance YesNo TrafficLight where  
ghci>yesnoIf [] "YEAH!" "NO!"
ghci>fmap (*2) [1..3]  
[2,4,6]
ghci>map (*2) [1..3]  
[2,4,6]
ghci>instance Functor Maybe where  
ghci>    fmap f (Just x) = Just (f x)  
ghci>    fmap f Nothing = Nothing  
ghci>fmap (++ " HEY GUYS IM INSIDE THE JUST") (Just "Something serious.") 
ghci>:k Int  
Int :: *
ghci>:k Maybe  
Maybe :: * -> *
ghci> :k Maybe Int  
Maybe Int :: *
ghci>:k Either  
Either :: * -> * -> *
ghci>:k Either String 
Either String :: * -> *
ghci>:k Either String Int  
Either String Int :: *
ghci>class Functor f where   
ghci>    fmap :: (a -> b) -> f a -> f b  
ghci>class Tofu t where  
ghci>    tofu :: j a -> t a j  
ghci>data Frank a b  = Frank {frankField :: b a} deriving (Show)  
ghci> :t Frank {frankField = Just "HAHA"}  
Frank {frankField = Just "HAHA"} :: Frank [Char] Maybe
ghci>:t Frank {frankField = Node 'a' EmptyTree EmptyTree}  
Frank {frankField = Node 'a' EmptyTree EmptyTree}
  :: Frank Char Tree
ghci>:t Frank {frankField = "YES"}  
Frank {frankField = "YES"} :: Frank Char []
ghci>tofu (Just 'a') :: Frank Char Maybe 
ghci>instance Tofu Frank where  
ghci>    tofu x = Frank x 
ghci>tofu (Just 'a') :: Frank Char Maybe  
ghci>data Barry t k p = Barry { yabba :: p, dabba :: t k }  
ghci>:k Barry
Barry :: (* -> *) -> * -> * -> *
ghci>
